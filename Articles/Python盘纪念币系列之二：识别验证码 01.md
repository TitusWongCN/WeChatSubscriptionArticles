> [上次](http://mp.weixin.qq.com/s?__biz=MzI2MjQ3NTQzOQ==&mid=100000121&idx=1&sn=da90bea2b1cf60f040b8ccb19eb9922e&chksm=6a4bdab95d3c53afa1e3fdb1b75d83b343f0ede413d1cda4aa17d706c59bb17228874c3fd1ff#rd)因为早已过了泰山币的预约时间，而近期又没有其他纪念币发行，所以我预约界面并不是我们想要的样子。而今天，聪明的我已经找到预约界面，虽然是阉割版。

## 预约界面

打开预约界面是这样的（网址可以在公众号后台发送“预约网址”获取）：

![预约界面](https://user-gold-cdn.xitu.io/2019/12/9/16eeaf42a01e30ef?w=808&h=590&f=png&s=60865)

可以看到需要的信息包括：
- 姓名
- 证件类型（默认为身份证）
- 证件号码
- 手机号码
- 图形验证码
- 短信验证码
- 兑换网点（被阉割，无法选择）
- 预约数量（直接阉割到不显示）
- 预约日期（无法输入）

为了实现自动化，我们一般会提前将诸如姓名、证件号码、手机号码等固定信息保存在配置文件中，利用程序自动读取，后期实战时会具体来讲。但是短信验证码目前暂时没有想到很好的解决办法，但本篇文章的主要内容不在这里，便不再赘述。

接下来我们来看看本文的重点————图形验证码。

![图形验证码](https://user-gold-cdn.xitu.io/2019/12/9/16eeaff4f8b790b2?w=624&h=50&f=png&s=9575)

如果等到预约的时候一个一个来查看并手动填写的话，要是遇到火爆的那很有可能是你刚填完额度就已经没有了。这里我们计划采用深度学习的方式用神经网络来帮我们解决这个问题（其实OCR也会是个好办法，因为这个验证码并不复杂，至少比12306的验证码简单的多）。

### 分析数据源

既然决定用深度学习，那么采集足够的数据就是第一件事了，毕竟神经网络是从大量数据中学习。

说到数据，就要用到我们在写爬虫时的功底了。首先我们来看看这个图片验证码是怎么生成的：
1. 浏览器按F12

![F12](https://user-gold-cdn.xitu.io/2019/12/9/16eeb06d91ac7dab?w=1358&h=621&f=png&s=99666)

2. 选择小箭头

![选择小箭头](https://user-gold-cdn.xitu.io/2019/12/9/16eeb077ddd9d851?w=102&h=55&f=png&s=1108)

3. 找到验证码的位置点击

![验证码的位置点击](https://user-gold-cdn.xitu.io/2019/12/9/16eeb08c3d2086c9?w=233&h=106&f=png&s=10295)

4. 观察源代码窗口

![观察源代码窗口](https://user-gold-cdn.xitu.io/2019/12/9/16eeb09e27243490?w=460&h=143&f=png&s=21515)

看到对应代码块中有src属性，熟悉html的都知道这个验证码就是从这里出来的，所以我们拷贝出来，如下所示

```html
https://eapply.abchina.com/coin/Helper/ValidCode.ashx?0.5805915363836303
```

打开一个隐身标签页，看看这个验证码是否需要cookies才能显示：

![](https://user-gold-cdn.xitu.io/2019/12/9/16eeb10b8e10dc58?w=843&h=225&f=png&s=19294)

从结果可以看到，在隐身窗口中依然可以打开。但是现在只有一张图，不知道这个链接是不是固定链接？我们刷新一下：

![](https://user-gold-cdn.xitu.io/2019/12/9/16eeb120ace5154e?w=842&h=223&f=png&s=18503)

验证码变了！

经过上述过程我们发现，图片验证码是由一个固定连接生成的，这个链接会动态的返回不一样的验证码给到前台。完美，这样的话我们的数据源就不用担心了。

### 采集数据

这里的图片验证码其实就是一张图片，本质上我们其实是要爬取网页图片。本文只写关键步骤，详细具体操作方法可以参考本公众号之前的一篇爬取网页图片的文章，[链接在此](http://mp.weixin.qq.com/s?__biz=MzI2MjQ3NTQzOQ==&mid=100000049&idx=1&sn=345e8b6ba1e6212b46e84d23fc411a7c&chksm=6a4bdaf15d3c53e78ad0c38d33959a083f13aa8ce5b468cbd02c738f02ffa8f26fda9069a858#rd)。

爬取图片我会用到requests库，然后通过二进制方式写入到本地文件：

```python
data = requests.get(image_url).content
with open('./{}.jpg'.format(image_index), 'wb') as f:
    f.write(data)
```

到现在为止，我们已经能将图片验证码保存到自己的机器上了。那么新的问题来了，我们到底需要多少张图呢？图太少，模型不容易达到最优；图太多，训练会花费过多时间。考虑到这个验证码的复杂度不高，另外10个数字加26个英文字母总共为36类，每一类按100张训练图片来计算，需要3600个字母或数字图。因为一张验证码有4个字母或者数字，那么总共需要800张验证码图片。还要注意的是，训练好模型之后需要有数据来进行测试，所以应该提前留出测试的验证码图片，按200张来算，故最终我们需要采集1000张图片验证码。

通过上述核心代码，很快我就拿到了这1000张图片验证码：

![验证码](https://user-gold-cdn.xitu.io/2019/12/9/16eeb297172340fa?w=657&h=469&f=png&s=153017)

![验证码](https://user-gold-cdn.xitu.io/2019/12/9/16eeb2aac1ae65b3?w=421&h=615&f=png&s=29569)

看到这么多验证码，我早已心痒痒想要盘它们了，奈何时间太晚，具体处理留到下一期吧。

本系列的所有源代码都会放在 [这个github仓库](https://github.com/TitusWongCN/AutoTokenAppointment) 里面，有需要可以参考，有问题欢迎指正，谢谢！


> 下期预告：验证码图片预处理